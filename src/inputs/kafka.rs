#![allow(unused)]

// Specification: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-kafka.html

use std::path::Path;

pub struct KafkaInput<'a> {
    auto_commit_interval_ms: Option<&'a str>,
    auto_offset_reset: Option<&'a str>,
    bootstrap_servers: Option<&'a str>,
    check_crcs: Option<&'a str>,
    client_id: Option<&'a str>,
    connections_max_idle_ms: Option<&'a str>,
    consumer_threads: Option<u64>,
    decorate_events: Option<bool>,
    enable_auto_commit: Option<&'a str>,
    exclude_internal_topics: Option<&'a str>,
    fetch_max_bytes: Option<&'a str>,
    fetch_max_wait_ms: Option<&'a str>,
    fetch_min_bytes: Option<&'a str>,
    group_id: Option<&'a str>,
    heartbeat_interval_ms: Option<&'a str>,
    jaas_path: Option<&'a Path>,
    kerberos_config: Option<&'a str>,
    key_deserializer_class: Option<&'a str>,
    max_partition_fetch_bytes: Option<&'a str>,
    max_poll_interval_ms: Option<&'a str>,
    max_poll_records: Option<&'a str>,
    metadata_max_age_ms: Option<&'a str>,
    partition_assignment_strategy: Option<&'a str>,
    poll_timeout_ms: Option<u64>,
    receive_buffer_bytes: Option<&'a str>,
    reconnect_backoff_ms: Option<&'a str>,
    request_timeout_ms: Option<&'a str>,
    retry_backoff_ms: Option<&'a str>,
    sasl_kerberos_service_name: Option<&'a str>,
    sasl_mechanism: Option<&'a str>,
    security_protocol: Option<&'a str>,
    send_buffer_bytes: Option<&'a str>,
    session_timeout_ms: Option<&'a str>,
    ssl_endpoint_identification_algorithm: Option<&'a str>,
    ssl_key_password: Option<&'a str>,
    ssl_keystore_location: Option<&'a Path>,
    ssl_keystore_password: Option<&'a str>,
    ssl_keystore_type: Option<&'a str>,
    ssl_truststore_location: Option<&'a Path>,
    ssl_truststore_password: Option<&'a str>,
    ssl_truststore_type: Option<&'a str>,
    topics: Option<Vec<&'a str>>,
    topics_pattern: Option<&'a str>,
    value_deserializer_class: Option<&'a str>,
}

impl<'a> KafkaInput<'a> {
    pub fn new() -> Self {
        Self {
            auto_commit_interval_ms: Some("5000"),
            auto_offset_reset: None,
            bootstrap_servers: Some("localhost:9092"),
            check_crcs: None,
            client_id: Some("logstash"),
            connections_max_idle_ms: None,
            consumer_threads: Some(1),
            decorate_events: Some(false),
            enable_auto_commit: Some("true"),
            exclude_internal_topics: None,
            fetch_max_bytes: None,
            fetch_max_wait_ms: None,
            fetch_min_bytes: None,
            group_id: Some("logstash"),
            heartbeat_interval_ms: None,
            jaas_path: None,
            kerberos_config: Some("org.apache.kafka.common.serialization.StringDeserializer"),
            key_deserializer_class: None,
            max_partition_fetch_bytes: None,
            max_poll_interval_ms: None,
            max_poll_records: None,
            metadata_max_age_ms: None,
            partition_assignment_strategy: None,
            poll_timeout_ms: Some(100),
            receive_buffer_bytes: None,
            reconnect_backoff_ms: None,
            request_timeout_ms: None,
            retry_backoff_ms: None,
            sasl_kerberos_service_name: None,
            sasl_mechanism: Some("GSSAPI"),
            security_protocol: Some("PLAINTEXT"),
            send_buffer_bytes: None,
            session_timeout_ms: None,
            ssl_endpoint_identification_algorithm: Some("https"),
            ssl_key_password: None,
            ssl_keystore_location: None,
            ssl_keystore_password: None,
            ssl_keystore_type: None,
            ssl_truststore_location: None,
            ssl_truststore_password: None,
            ssl_truststore_type: None,
            topics: Some(vec!["logstash"]),
            topics_pattern: None,
            value_deserializer_class: Some(
                "org.apache.kafka.common.serialization.StringDeserializer",
            ),
        }
    }
}
